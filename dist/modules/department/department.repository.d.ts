import { Repository } from 'typeorm';
import { Department } from './entities/department.entity';
import { IDepartmentRepository } from './interfaces/department.repository.interface';
export declare class DepartmentRepository implements IDepartmentRepository {
    private readonly departmentRepository;
    constructor(departmentRepository: Repository<Department>);
    findById(id: string): Promise<Department | null>;
    findByCode(departmentCode: string): Promise<Department | null>;
    save(department: Department): Promise<Department>;
    delete(id: string): Promise<void>;
    softDelete(id: string): Promise<void>;
    findAll(): Promise<Department[]>;
    findActive(): Promise<Department[]>;
    findInactive(): Promise<Department[]>;
    findByIds(ids: string[]): Promise<Department[]>;
    findRootDepartments(): Promise<Department[]>;
    findChildrenByParentId(parentId: string): Promise<Department[]>;
    findDescendantsByParentId(parentId: string): Promise<Department[]>;
    findAncestorsByDepartmentId(departmentId: string): Promise<Department[]>;
    findByBranchId(branchId: string): Promise<Department[]>;
    findByDepartmentTypeId(departmentTypeId: string): Promise<Department[]>;
    findByBranchIds(branchIds: string[]): Promise<Department[]>;
    findByDepartmentTypeIds(departmentTypeIds: string[]): Promise<Department[]>;
    searchByKeyword(keyword: string): Promise<Department[]>;
    searchByHeadOfDepartment(headOfDepartment: string): Promise<Department[]>;
    searchByHeadNurse(headNurse: string): Promise<Department[]>;
    findWithPagination(limit: number, offset: number, sortBy?: string, sortOrder?: 'ASC' | 'DESC', filters?: {
        isActive?: boolean;
        branchId?: string;
        departmentTypeId?: string;
        parentDepartmentId?: string;
        search?: string;
    }): Promise<[Department[], number]>;
    countTotal(): Promise<number>;
    countActive(): Promise<number>;
    countInactive(): Promise<number>;
    countByStatus(isActive: boolean): Promise<number>;
    countByBranch(branchId: string): Promise<number>;
    countByDepartmentType(departmentTypeId: string): Promise<number>;
    countByParent(parentDepartmentId: string): Promise<number>;
    getNextSortOrder(): Promise<number>;
    existsByCode(departmentCode: string, excludeId?: string): Promise<boolean>;
    existsByName(departmentName: string, excludeId?: string): Promise<boolean>;
    existsByShortName(shortName: string, excludeId?: string): Promise<boolean>;
    isCircularReference(departmentId: string, parentId: string): Promise<boolean>;
    getMaxHierarchyDepth(): Promise<number>;
}
